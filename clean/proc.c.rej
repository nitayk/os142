--- proc.c	(revision 3)
+++ proc.c	(working copy)
@@ -18,6 +18,7 @@
 int nextpid = 1;
 extern void forkret(void);
 extern void trapret(void);
+extern uchar num_of_shares[];
 
 static void wakeup1(void *chan);
 
@@ -161,6 +162,46 @@
   return pid;
 }
 
+
+// Create a new process with COW
+// Sets up stack to return as if from system call.
+// Caller must set state of returned proc to RUNNABLE.
+int
+cowfork(void)
+{
+  int i, pid;
+  struct proc *np;
+
+  // Allocate process.
+  if((np = allocproc()) == 0)
+    return -1;
+
+  // Copy process state from p.
+  if((np->pgdir = copyuvm_cow(proc->pgdir, proc->sz)) == 0){
+    kfree(np->kstack);
+    np->kstack = 0;
+    np->state = UNUSED;
+    return -1;
+  }
+  np->sz = proc->sz;
+  np->parent = proc;
+  *np->tf = *proc->tf;
+
+  // Clear %eax so that fork returns 0 in the child.
+  np->tf->eax = 0;
+
+  for(i = 0; i < NOFILE; i++)
+    if(proc->ofile[i])
+      np->ofile[i] = filedup(proc->ofile[i]);
+  np->cwd = idup(proc->cwd);
+ 
+  pid = np->pid;
+  np->state = RUNNABLE;
+  safestrcpy(np->name, proc->name, sizeof(proc->name));
+  return pid;
+}
+
+
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
@@ -180,7 +221,7 @@
       proc->ofile[fd] = 0;
     }
   }
-
+  
   iput(proc->cwd);
   proc->cwd = 0;
 
@@ -188,7 +229,8 @@
 
   // Parent might be sleeping in wait().
   wakeup1(proc->parent);
-
+  
+  
   // Pass abandoned children to init.
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->parent == proc){
@@ -381,7 +423,7 @@
   proc->chan = chan;
   proc->state = SLEEPING;
   sched();
-
+  
   // Tidy up.
   proc->chan = 0;
 
@@ -452,7 +494,7 @@
   [RUNNING]   "run   ",
   [ZOMBIE]    "zombie"
   };
-  int i;
+  int i,j;
   struct proc *p;
   char *state;
   uint pc[10];
@@ -470,8 +512,52 @@
       for(i=0; i<10 && pc[i] != 0; i++)
         cprintf(" %p", pc[i]);
     }
-    cprintf("\n");
+    
+    pde_t * pgdir = p -> pgdir;
+    cprintf("Page Tables:\n");
+
+    cprintf("    memory location of page directory = %p\n",pgdir);
+
+    for (i=0 ; i < NPDENTRIES ; i++) {
+    	if ((pgdir[i] & PTE_P) && (pgdir[i] & PTE_U) && (pgdir[i] & PTE_A) ) {	// check if USER PAGE and PRESENT
+    		cprintf("    pdir PTE %d,%d:\n",i,pgdir[i]>>12);
+    		pde_t * pgtbl = P2V(PTE_ADDR(pgdir[i]));
+    		cprintf("        memory location of page table = %p\n",pgtbl);
+    	    for (j=0 ; j < NPTENTRIES; j++) {
+    	    	if ((pgtbl[j] & PTE_P) && (pgtbl[j] & PTE_U) && (pgtbl[j] & PTE_A))
+    	    		cprintf("        ptbl PTE %d,%d,%p\n",j,pgtbl[j]>>12,P2V(PTE_ADDR(pgtbl[j])));
+    	    }
+    	}
+    }
+    
+	cprintf("    Port Mappings:\n");
+	for (i=0 ; i < NPDENTRIES ; i++) {
+		if ((pgdir[i] & PTE_P) && (pgdir[i] & PTE_U) && (pgdir[i] & PTE_A)) {	// check if USER PAGE and PRESENT
+			pde_t * pgtbl = P2V(PTE_ADDR(pgdir[i]));
+			for (j=0 ; j < NPTENTRIES; j++) {
+				if ((pgtbl[j] & PTE_P) && (pgtbl[j] & PTE_U) && (pgtbl[j] & PTE_A)) {
+					char* readonly = "y";
+					char* shared = "n";
+					int sharedCounter = (int)num_of_shares[PTE_ADDR(pgtbl[j])/PGSIZE];
+					if ((pgtbl[j] & PTE_W) > 0){
+						readonly = "n";
+					} else {
+						if (sharedCounter == 0 && (pgtbl[j] & PTE_WAS_WRITABLE)){
+							readonly = "n";
+						}
+					} if ((pgtbl[j]&PTE_SH ) > 0) {
+						if (sharedCounter == 0) {
+							shared = "n";
+						} else
+							shared = "y";
+					}
+					cprintf("        %d -> %d,%s,%s\n",(i<<10)|j,pgtbl[j]>>12,readonly,shared);
+				}
+			}
+		}
+	}
   }
 }
 
 
+
