--- exec.c	(revision 3)
+++ exec.c	(working copy)
@@ -12,7 +12,7 @@
 {
   char *s, *last;
   int i, off;
-  uint argc, sz, sp, ustack[3+MAXARG+1];
+  uint argc, sz, sp, ustack[3+MAXARG+1],writeFlag;
   struct elfhdr elf;
   struct inode *ip;
   struct proghdr ph;
@@ -32,8 +32,10 @@
   if((pgdir = setupkvm(kalloc)) == 0)
     goto bad;
 
-  // Load program into memory.
-  sz = 0;
+  // Load program into memory.- Task 2
+  sz = PGSIZE;
+  //sz = 0; old - changed for task2 , no access to address 0
+  
   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
       goto bad;
@@ -43,8 +45,14 @@
       goto bad;
     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
       goto bad;
-    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
+    if (ph.flags & ELF_PROG_FLAG_WRITE)
+    	writeFlag = 1;
+    else
+    	writeFlag = 0;
+    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz,writeFlag) < 0)
+    {
       goto bad;
+    }
   }
   iunlockput(ip);
   ip = 0;
@@ -52,6 +60,7 @@
   // Allocate two pages at the next page boundary.
   // Make the first inaccessible.  Use the second as the user stack.
   sz = PGROUNDUP(sz);
+  
   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
     goto bad;
   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
